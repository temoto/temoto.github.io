<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xmlns:thr="http://purl.org/syndication/thread/1.0">
  <id>https://temoto.github.io</id>
  <title>Temoto space</title>
  <updated>2009-11-16T00:00:00Z</updated>
  <author><name>Temoto</name></author>
  <link href="https://temoto.github.io" rel="alternate"></link>
  <generator uri="https://github.com/piranha/gostatic">gostatic</generator>

<entry>
  <id>a/kak-rabotayut-domeny.html</id>
  <author><name>Temoto</name></author>
  <title type="html">Как работают домены</title>
  <published>2009-11-16T00:00:00Z</published>
  <category term="интернет"></category><category term="технологии"></category>
  <link href="https://temoto.github.io/a/kak-rabotayut-domeny.html" rel="alternate"></link>
  <content type="html">
  &lt;p&gt;&lt;h2&gt;Основы&lt;/h2&gt;
&lt;p&gt;Домен &amp;mdash; это (грубо говоря) имя в интернете. Вы в браузере пишете ag.ru, браузер с помощью механизма &lt;abbr title=&#34;Domain Name System&#34;&gt;DNS&lt;/abbr&gt; (об этом ниже)
   узнаёт, что этому имени соответствует адрес &lt;code&gt;194.67.1.14&lt;/code&gt; и дальше работа идёт только с числовым адресом, имя не используется.
   А нам, людям, удобнее работать с короткими, осмысленными именами.
   Про &lt;a href=&#34;http://ru.wikipedia.org/wiki/Доменное_имя&#34; rel=&#34;external nofollow&#34;&gt;доменные имена на википедии&lt;/a&gt;.
&lt;p&gt;Домены организованы в дерево. Корень дерева - зона &amp;ldquo;.&amp;rdquo;, можно сказать, домен нулевого уровня. Его потомки &amp;mdash; несколько десятков доменов первого уровня:
   com, biz, org, ru, info, mobi, tv, ua, так называемые, &lt;a href=&#34;http://en.wikipedia.org/wiki/Top-level_domain&#34; rel=&#34;external nofollow&#34;&gt;TLD: Top-Level Domains&lt;/a&gt;.
   Для узла дерева, домена второго уровня example.com, все его непосредственные потомки (www.example.com,
   mail.example.com, foobar.example.com, &amp;hellip;) образуют зону example.com.
&lt;p&gt;Регистр букв в имени домена не имеет значения. &lt;code&gt;EXAMPLE.COM&lt;/code&gt; и &lt;code&gt;exAMple.Com&lt;/code&gt; обозначают один и тот же домен.
   Для удобства, имена доменов всегда пишут в нижнем регистре.
&lt;p&gt;В имени домена разрешены символы a-z, 0-9 и дефис. Дефис не может быть первым и последним символом. Также запрещён частный случай, когда два дефиса стоят на 3 и 4 позиции (ab--cd).
   Это ограничение однозначно отделяет &lt;small&gt;обычные&lt;/small&gt; ASCII домены от пуникода.
&lt;p&gt;Для пользователей существуют юникодные домены, (например, &lt;a href=&#34;http://сиськи.su/&#34;&gt;сиськи.su&lt;/a&gt;) но технически их нет,
   браузер преобразует юникодную запись в ASCII при помощи специальной кодировки &lt;a href=&#34;http://en.wikipedia.org/wiki/Punycode&#34; rel=&#34;external nofollow&#34;&gt;Punycode&lt;/a&gt; 
   (&lt;code&gt;xn--h1aaf0ab0e.su&lt;/code&gt;) и дальше работает старый добрый ASCII.
&lt;h2&gt;Реестр и регистраторы&lt;/h2&gt;
&lt;p&gt;В общем случае есть реестр зоны [первого уровня], регистраторы и продавцы (реселлеры регистраторов). У каждой зоны первого уровня есть реестр, можно ещё сказать, координатор.
   Это организация, которая хранит, обслуживает и предоставляет доступ для регистраторов к центральной базе данных доменов этой зоны.
   По понятным причинам, некоторые организации фактически обслуживают несколько зон, это касается, например, зон RU и РФ.
   Во многих национальных доменах [первого уровня] координатор и является единственным регистратором, то есть отсутствует институт распределённой регистрации доменов.
&lt;p&gt;Реестр продаёт регистраторам право доступа к зоне.
   Реестр &amp;mdash; это сугубо техническая организация, предоставляющая программный интерфейс (API) для регистраторов.
&lt;p&gt;А вот регистраторы уже работают с розничными клиентами, людьми.
   В зоне RU реестром является &lt;a href=&#34;http://www.ripn.net:8082/about/&#34; rel=&#34;external nofollow&#34;&gt;РосНИИРОС&lt;/a&gt;, а самым крупным регистратором &amp;mdash; &lt;a href=&#34;http://nic.ru/&#34; rel=&#34;external nofollow&#34;&gt;РуЦентр&lt;/a&gt;.
&lt;p&gt;Чтобы стать регистратором, нужно выполнить разные строгие требования реестра.
   Вот каковы &lt;a href=&#34;http://www.cctld.ru/ru/docs/rfacc.php&#34;&gt;требования к кандидату в регистраторы в России&lt;/a&gt;.
   &lt;a href=&#34;http://www.cctld.ru/ru/registrators/&#34;&gt;Список регистраторов&lt;/a&gt; растёт, и на 15 ноября 2009 года насчитывает 23 штуки.
&lt;p&gt;Реселлеры регистраторов &amp;mdash; это реселлеры, как везде. Покупают подешевле, продают подороже.
   Чаще всего регистраторы также предоставляют программный интерфейс (&lt;abbr title=&#34;Application Programming Interface&#34;&gt;API&lt;/abbr&gt;) для реселлеров,
   что позволяет практически полностью скрыть от пользователя тот факт, что он покупает домен не из первых рук.
   Хотя известны случаи, когда некоторые реселлеры продавали домены намного дешевле, чем регистратор в розницу.
   А если нет разницы, зачем платить больше? Здесь нет подвоха, правда.
&lt;h2&gt;Регистрация домена&lt;/h2&gt;
&lt;p&gt;Регистрация состоит из обращения к регистратору (или реселлеру, для пользователя разницы нет);
   это как придти в магазин и сказать, мол, хочу купить такой-то домен. К слову, в зоне RU на конец 2009 года зарегистрировано порядка 2.5 млн. доменов,
   а в зоне COM &amp;mdash; порядка 80 млн. То есть вероятность, что имя, которое вы хотите зарегистрировать, уже занято сильно варьируется в разных зонах первого уровня.
&lt;p&gt;Если этот домен уже кем-то куплен (возможно, через другого регистратора, реестр-то один), то &amp;hellip;пролёт.
&lt;p&gt;Проверить, был ли домен свободен, можно и без намерений о покупке.
   Для этого нужно воспользоваться т.н. сервисом WHOIS.
   Например, здесь &lt;a href=&#34;http://swhois.net/&#34; rel=&#34;external nofollow&#34;&gt;swhois.net&lt;/a&gt; или здесь &lt;a href=&#34;https://www.nic.ru/whois/?wi=1&#34; rel=&#34;external nofollow&#34;&gt;nic.ru&lt;/a&gt;.
   Красноглазые друзья могут написать &lt;code&gt;whois имя-домена.зона&lt;/code&gt; в консоли.
   Поскольку, формат ответа не стандартизирован, нельзя описать что конкретно искать в ответе, чтобы понять, что домен свободен,
   но, в целом, будет ясно. Если домен занят, то выводится куча (или немножко) информации о его владельце.
   Здесь кто-то может возразить, мол, да проще в браузере ввести адрес и сразу будет ясно.
   Действительно, в 99% случаев это работает, потому что, чаще всего, домен покупают, чтобы сделать на нём публичный сайт.
   Но это не всегда так. Некоторые домены куплены и принадлежат конкретным людям, но сайтов на них нет.
&lt;p&gt;Вам продают две вещи:
&lt;ol&gt;&lt;li&gt;формальное временное право владения доменом. Самая близкая аналогия &amp;mdash; аренда.
    &lt;li&gt;доступ к изменению NS-серверов домена
&lt;/ol&gt;
&lt;p&gt;Домен продают именно вам, это, практически, ваша вещь, в реестре хранится информация о владельце.
   В случае проблем с регистратором, можно перенести домен к другому, при этом, на всех этапах переноса,
   владельцем домена является только его покупатель.
&lt;p&gt;Нет никаких технических ограничений на этот счёт, но почему-то так сложилось, что все реестры регистрируют
   домены минимум, на 1 год (в зоне CO.UK на 2). По истечении этого срока регистрацию домена необходимо продлить.
   Продление, как правило, стоит немного дешевле регистрации. Некоторые реестры позволяют &amp;ldquo;продлевать домены&amp;rdquo; на несколько лет вперёд.
   Право владения доменом в зоне ru можно продлить только на 1 год. Ещё на год можно будет продлить в следующем году.
   Все регистраторы предоставляют услугу &amp;ldquo;автопродления&amp;rdquo;, когда с вашего баланса в нужный момент времени списывается
   сумма необходимая для продления домена.
&lt;h2&gt;DNS резолвинг&lt;/h2&gt;
&lt;p&gt;Полагаю, что читатель знаком с понятием &lt;a href=&#34;http://en.wikipedia.org/wiki/Internet_Protocol&#34; rel=&#34;external nofollow&#34;&gt;IP адрес&lt;/a&gt; и понимает, что домены,
   в общем-то, нужны только для удобства людей. IP пакеты ходят между компьютерами с числовыми адресами. Например, домену python.org соответствует IPv4 адрес 82.94.164.162.
   Чтобы выяснить это соответствие, используется DNS: Domain Name System. Это распределённая база данных, её работа довольно сложна, но интересна.
&lt;p&gt;В системе DNS учавствуют серверы и клиенты. При помощи специального протокола DNS клиенты делают запросы, а серверы им отвечают.
   Обычно, для DNS запросов используется транспортный протокол &lt;a href=&#34;http://en.wikipedia.org/wiki/User_Datagram_Protocol&#34; rel=&#34;external nofollow&#34;&gt;UDP&lt;/a&gt;
   (иногда, &lt;a href=&#34;http://en.wikipedia.org/wiki/Transmission_Control_Protocol&#34; rel=&#34;external nofollow&#34;&gt;TCP&lt;/a&gt;, но этот вариант используется намного реже
   из-за накладных расходов на создание соединения). Зарезервированный номер UDP и TCP порта для DNS: 53.
   Протокол бинарный, большинство запросов и ответов помещаются в UDP пакеты с ограничением 512 байт.
&lt;p&gt;DNS не самодостаточна. Чтобы &amp;ldquo;всё завелось&amp;rdquo;, в конце концов, какой-то клиент должен сделать запрос к какому-то серверу, не зная его имени.
   Обычно, эту проблему решает &lt;a href=&#34;http://en.wikipedia.org/wiki/Dynamic_Host_Configuration_Protocol&#34; rel=&#34;external nofollow&#34;&gt;DHCP сервер&lt;/a&gt; интернет-провайдера,
   который по специальному протоколу, помимо прочего, сообщает IP адреса своих кеширующих DNS серверов. Кроме того, существуют сервисы DNS серверов,
   такие как &lt;a href=&#34;http://www.opendns.com/&#34; rel=&#34;external nofollow&#34;&gt;OpenDNS&lt;/a&gt;, которые работают благодаря постоянным IP адресам.
&lt;p&gt;DNS запросы бывают &amp;ldquo;прямые&amp;rdquo; и рекурсивные. Прямой запрос предназначается конкретному серверу.
   Клиента интересует только та информация, которую может дать именно этот сервер.
   Рекурсивный запрос, наоборот, предполагает, что клиенту неважно откуда будет информация, важно получить ответ.
   Кеширующие DNS серверы при получении рекурсивного запроса сами инициируют новый запрос к вышестоящему (upstream) серверу.
   Такая цепочка может дойти до сервера регистратора или до корневых серверов (серверы зон первого уровня).
&lt;p&gt;Name-серверы (NS) хранят информацию о зоне. Для NS, зона это набор записей. DNS запись состоит из:
&lt;ol&gt;&lt;li&gt;класс. На практике используется один класс: IN (Internet), но
        &lt;a href=&#34;http://www.iana.org/assignments/dns-parameters&#34; rel=external&gt;предусмотрена поддержка и других классов&lt;/a&gt;.
    &lt;li&gt;тип, например, &lt;code&gt;A&lt;/code&gt; означает, что имя в этой записи является синонимом (alias) к указанному в значении IPv4 адресу.
        Это самый распространённый тип записей.
    &lt;li&gt;имя, например, &lt;code&gt;www&lt;/code&gt;. В различных программах редактирования зон, часто используется
        специальное имя &lt;code&gt;@&lt;/code&gt; как короткая ссылка на имя зоны.
        Например, запись &lt;code&gt;@ A 1.2.3.4&lt;/code&gt; в зоне example.com означает присвоение указанного адреса для собственно имени example.com.
        После программы, в базу данных DNS заносится запись &lt;code&gt;example.com IN A 1.2.3.4&lt;/code&gt;.
        То есть в сетевом протоколе DNS такое имя как &lt;code&gt;@&lt;/code&gt; никогда не фигурирует, оно есть только для удобства настройки зоны.
    &lt;li&gt;значение, например, IP адрес &lt;code&gt;1.2.3.4&lt;/code&gt;. Или текстовое имя другого домена.
        Или вообще, просто кусок текста. Всё зависит от типа записи.
    &lt;li&gt;TTL (time to live), например, &lt;code&gt;1440&lt;/code&gt;. Время в секундах, в течение которого полученная информация в записи считается действительной.
        Используется для кеширования.
&lt;/ol&gt;
&lt;p&gt;В DNS используется система делегирования полномочий. Корневые сервера реестра делегируют полномочия выдавать ответы по определённым зонам на NS (name server)
   этих зон. Когда кто-то спрашивает NS о его зоне, он помечает ответ как авторитетный (authoritative).
   Другие NS в ответ на ваш запрос, могут сказать &lt;q&gt;я не знаю, но вот он знает&lt;/q&gt;.
   Такая цепочка может быть бесконечной. Предполагается, что в какой-то момент (на практике это первый же сервер после перенаправления)
   сервер даст вам конкретную информацию: либо &lt;q&gt;я в ответе, вот записи&lt;/q&gt;, либо &lt;q&gt;я не знаю и не знаю кто знает&lt;/q&gt;.
&lt;p&gt;Специальная запись SOA используется для выяснения кто отвечает за эту зону (какой NS является авторитетным, первичным источником информации зоны).
   Запись SOA содержит:
&lt;ol&gt;&lt;li&gt;адрес (чаще всего имя домена, типа &lt;code&gt;ns1.example.com&lt;/code&gt;) т.н. первичного NS
    &lt;li&gt;email адрес администратора зоны
    &lt;li&gt;и несколько других полей. Версия (serial) зоны и таймауты, в течение которых действительна данная информация.
&lt;/ol&gt;
&lt;p&gt;Существуют специальные, т.н. корневые сервера. Они хранят информацию о том какие зоны обслуживаются какими NS,
   то есть, &lt;code&gt;SOA&lt;/code&gt; записи. Можно спросить корневой сервер об абсолютно любой записи любой зоны и гарантированно
   никогда не получить авторитетный ответ. :) Но вы получите адрес NS, который, по-мнению корневого сервера обслуживает
   интересующую вас зону. Нужно повторить запрос к полученному NS. Такие повторы называются рекурсивным резолвингом.
&lt;h2&gt;Безопасность&lt;/h2&gt;
&lt;p&gt;Использование UDP, в частности, означает, что вы могли послать запрос одному компьютеру, а ответил другой.
   DNS протокол не даёт ровным счётом никаких средств для защиты передаваемой информации.
   Также нет никакого способа проверить, что ответ не был изменён кем-то по дороге до вашего компьютера.
   Отправка запроса к DNS серверу и ожидание ответа называется резолвингом (DNS resolving).
   Строго говоря, это название относится только к &lt;code&gt;A&lt;/code&gt; запросам, которые используются для выяснения какой адрес
   соответствует указанному имени. В более общем смысле, обращение к DNS называется (сюрприз!) запросом (query).
   Но, в действительности, резолвинг &lt;code&gt;A&lt;/code&gt; записей это 99% использования DNS.
   Оба названия имеют право на жизнь, к тому же нет принципиальной разницы.
&lt;p&gt;DNS &amp;mdash; распределённая база данных, к ней применимы стандартные правила доверия в распределённой среде.
   Доверять нельзя никому. Любой администратор может запустить DNS сервер, настроить у себя зону,
   к примеру, google.com, но другими адресами, ведущими на его серверы. Браузер не заметит подмены, человека тоже можно обмануть.
   В чём подвох? В том, что никакой браузер не будет спрашивать ваш левый DNS сервер.
&lt;p&gt;DNS уязвима к т.н. атакам отравления кеша. При различных методиках, суть атаки сводится к тому, что в кеширующие DNS
   попадает неверная информация, например &lt;code&gt;A&lt;/code&gt; записи, указывающие на адреса серверов злых умышленников.
   Пользователь, при этом не имеет возможности проверить достоверность полученной информации.
&lt;h2&gt;Делегирование&lt;/h2&gt;
&lt;p&gt;Делегирование домена это изменение его &lt;code&gt;SOA&lt;/code&gt; записи в родительской зоне.
   Делегирование домена temoto.ru это изменение записи &lt;code&gt;temoto.ru SOA &amp;hellip;&lt;/code&gt; в зоне ru. При покупке домена второго уровня, в зоне
   первого уровня появится &lt;code&gt;SOA&lt;/code&gt; запись о новом домене. Зоны первого уровня обслуживаются DNS серверами реестров.
&lt;p&gt;В общем случае, сразу после регистрации существование домена можно обнаружить только с помощью WHOIS. Для перекупки
   коротких/интересных имён этого достаточно, но чаще всего люди хотят сделать с доменом что-то полезное.
   Например, чтобы вводя в адресной строке &lt;code&gt;&lt;a href=&#34;http://mydomain.tld/&#34;&gt;http://mydomain.tld/&lt;/a&gt;&lt;/code&gt; пользователь попадал на ваш сайт.
   Как правило, эту задачу решает регистратор. Например, &lt;a href=&#34;http://reggi.ru/&#34; rel=external&gt;Рэгги&lt;/a&gt; (и почти все остальные)
   предоставляет бесплатные DNS сервера при покупке домена. И делегирует ваш домен на свои NS. И в этих NS есть &lt;code&gt;A&lt;/code&gt; запись,
   указывающая на IP адрес специального веб-сервера, который выдаёт страницу &amp;ldquo;домен зарегистрирован&amp;rdquo;.
&lt;p&gt;Обычно говорят &lt;q&gt;делегировать на такие-то сервера&lt;/q&gt;. Это подразумевает создание в корневом реестре не только SOA, но и нескольких NS записей.
   NS записи указывают на авторитетные NS сервера, которые обслуживают данную зону.
&lt;h2&gt;Кеширование&lt;/h2&gt;
&lt;p&gt;DNS &amp;mdash; это, пожалуй, самый большой и успешный пример использования проксирующего кеширования.
&lt;p&gt;Поскольку записи в зонах изменяются относительно редко, нет смысла после каждого клика по ссылке резолвить имя домена в ссылке.
   Помните, в DNS записи есть TTL? Однажды получив, скажем, IP адрес из записи &lt;code&gt;example.com A 192.0.32.10&lt;/code&gt;, с TTL,
   скажем 120, мы имеем полное право в течение 120 секунд предполагать, что адрес example.com является &lt;code&gt;192.0.32.10&lt;/code&gt;.
   А вот после 120 секунд, теоретически, нужно сделать новый запрос. Поэтому, на практике, TTL делают довольно большим: 6, 12 часов, иногда больше.
&lt;p&gt;Кроме того, велика вероятность, что многие из клиентов одного интернет-провайдера (ISP) ходят на пересекающееся множество сайтов,
   следовательно, они резолвят одни и те же имена. Хорошо, после резолвинга браузер запомнит адрес, но клиентов тысячи.
   Поэтому для экономии трафика и ускорения резолвинга все интернет-провайдеры устанавливают у себя т.н. кеширующий DNS сервер.
   На любой прямой запрос он ответит неудачей, потому что он не содержит никаких записей. Но получив рекурсивный запрос,
   кеширующий DNS сервер сделает такой же запрос к вышестоящему серверу и так далее, пока не будет получен авторитетный ответ,
   который по цепочке обратно будет возвращён клиенту.
&lt;p&gt;Однако, если кеширующий DNS сервер недавно уже делал такой же запрос, получил необходимую запись и информация ещё не
   устарела (не истёк срок TTL), то он отдаст информацию &amp;ldquo;сразу&amp;rdquo;, не делая запроса к вышестоящему серверу. В этом весь смысл кеширования.
   К сожалению, на практике, многие интернет-провайдеры настраивают свои кеширующие DNS сервера таким образом, что они игнорируют TTL в записях
   и сохраняют их в кеше на более длительный срок. Поэтому, когда вы меняете адрес своего сайта, может пройти несколько дней,
   прежде чем абсолютно везде, на всей планете этот адрес действительно изменится. Но в основном, конечно, всё проходит намного быстрее.
   Всё зависит от TTL.
&lt;p&gt;В популярном (и &lt;a href=&#34;http://cr.yp.to/djbdns/res-disaster.html&#34; rel=external&gt;дырявом&lt;/a&gt;) DNS пакете BIND нет чёткого разделения между кеширующим и авторитетным DNS серверами.
   Из-за этого новички-администраторы делают неверные предположения о схеме работы DNS и допускают ошибки.
&lt;h2&gt;Итоги&lt;/h2&gt;
&lt;p&gt;Люди используют осмысленные символьные имена доменов, т.к. оперировать адресами типа &lt;code&gt;192.0.32.10&lt;/code&gt; неудобно.
   Домены имеют иерархическую структуру начиная с доменов первого уровня (TLD) и без ограничений по глубине.
&lt;p&gt;Реестр это организация, которая отвечает за техническое функционирование DNS-серверов зоны первого уровня.
   Регистраторы заключают договора с реестрами и предоставляют услуги по регистрации, продлению, делегированию и переносу доменов
   для частных лиц и компаний.
&lt;p&gt;DNS это распределённая база данных, которая состоит из зон. Зона &amp;mdash; это набор DNS записей. Клиенты делают запросы к серверам
   посредством DNS протокола. Как правило, запросы отправляются по UDP. DNS уязвим к широкому спектру атак, включая man-in-the-middle.
&lt;p&gt;В DNS очень активно используется кеширование. Это позволяет снизить нагрузку на сеть и часто является причиной непонимания
   между покупателями доменов и поддержкой регистратора.
&lt;hr&gt;&lt;/p&gt;

&lt;div class=&#34;vcard height-112&#34; rel=&#34;author&#34;&gt;
    &lt;a class=&#34;url&#34; href=&#34;https://plus.google.com/109869205442495270563?rel=author&#34; rel=&#34;author&#34;&gt;
        &lt;img class=&#34;left photo photo-100&#34; src=&#34;https://lh6.googleusercontent.com/-0tA2B1FBAwE/USyzpBsFKJI/AAAAAAAAF5Y/w4qM7aZWdSU/s100/photo.jpg&#34; alt=&#34;&#34;&gt;
    &lt;/a&gt;
    Автор: &lt;span class=&#34;fn&#34;&gt;Сергей Шепелев&lt;/span&gt;, &lt;span class=&#34;date&#34;&gt;2009-11-16&lt;/span&gt;.

    &lt;p&gt;Если вы заметили ошибку или просто хотите поболтать.&lt;/p&gt;
    &lt;address&gt;
        &lt;p&gt;Email: &lt;strong class=&#34;email&#34;&gt;temotor@gmail.com&lt;/strong&gt;
    &lt;/address&gt;
&lt;/div&gt;
</content>
</entry>
<entry>
  <id>a/db-enum-test-str-vs-int.html</id>
  <author><name>Temoto</name></author>
  <title type="html">Сравнение скорости баз данных с численными и строковыми перечислениями</title>
  <published>2008-07-15T00:00:00Z</published>
  <category term="программирование"></category><category term="python"></category><category term="sql"></category>
  <link href="https://temoto.github.io/a/db-enum-test-str-vs-int.html" rel="alternate"></link>
  <content type="html">
  &lt;p&gt;&lt;h2&gt;Посыл&lt;/h2&gt;
&lt;p&gt;В мае сего года, Александр Кошелев написал &lt;a href=&#34;http://webnewage.org/post/2008/5/12/perechisleniya-na-sluzhbe-dobra/&#34;&gt;как сделать перечисления в джанге&lt;/a&gt;. И большое ему за это спасибо. Но. Александр выступает за читабельную raw базу, а я против. Вот, что он пишет:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Потом, что будет если вы просмотрите raw базу? Увидите там кучу строк, где в поле &amp;ldquo;тип&amp;rdquo; какие-то не понятные числа&lt;/p&gt;
&lt;p&gt;надо использовать строковые литералы для обозначения типа и сменить тип поля в модели на CharField. И пускай это чуть-чуть менее эффективно с точки зрения объема информации.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Уважаемый Александр! Насрать на размер базы! Не в этом дело.&lt;/p&gt;
&lt;p&gt;О том, почему &lt;strong&gt;в базе должны храниться чиселки-айдишники вместо строк&lt;/strong&gt;, там где это можно, низлежащий тест на скорость.&lt;/p&gt;
&lt;h2&gt;Тест на скорость&lt;/h2&gt;
&lt;p&gt;Для теста использовалась табличка примерно такой структуры:
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;имя&lt;/th&gt;&lt;th&gt;тип поля&lt;/th&gt;&lt;th&gt;индекс&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;
&lt;tbody&gt;
    &lt;tr&gt;&lt;td&gt;id&lt;/td&gt;&lt;td&gt;int&lt;/td&gt;&lt;td&gt;PK&lt;/td&gt;&lt;/tr&gt;
    &lt;tr&gt;&lt;td&gt;name&lt;/td&gt;&lt;td&gt;varchar(100)&lt;/td&gt;&lt;td&gt;-&lt;/td&gt;&lt;/tr&gt;
    &lt;tr&gt;&lt;td&gt;pass&lt;/td&gt;&lt;td&gt;varchar(50)&lt;/td&gt;&lt;td&gt;-&lt;/td&gt;&lt;/tr&gt;
    &lt;tr&gt;&lt;td&gt;email&lt;/td&gt;&lt;td&gt;varchar(100)&lt;/td&gt;&lt;td&gt;-&lt;/td&gt;&lt;/tr&gt;
    &lt;tr&gt;&lt;td&gt;atype&lt;/td&gt;&lt;td&gt;&lt;strong&gt;int&lt;/strong&gt; и &lt;strong&gt;varchar(30)&lt;/strong&gt;&lt;/td&gt;&lt;td&gt;index&lt;/td&gt;&lt;/tr&gt;
    &lt;tr&gt;&lt;td&gt;i1&lt;/td&gt;&lt;td&gt;float&lt;/td&gt;&lt;td&gt;-&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;&lt;/p&gt;
&lt;p&gt;Табличка заполнялась примерно 2 миллионами записей, в которых все поля - случайные слова. Для atype int использовалось 7 цифр, для atype str - около 40 слов.&lt;/p&gt;
&lt;p&gt;Тест производился на двух СУБД: SQLite 3.4 и Postgres 8.3. Нужно будет еще найти время, провести его на MySQL, конечно.&lt;/p&gt;
&lt;p&gt;Суть теста грубо неумелая: выбрать всех юзеров where atype = каждое возможное его значение и выбрать всех юзеров group by atype.&lt;/p&gt;
&lt;p&gt;Запросы:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;SELECT COUNT(&lt;em&gt;) FROM tt WHERE atype=x;&lt;/code&gt;&lt;br&gt;
&lt;code&gt;SELECT COUNT(&lt;/em&gt;) FROM tt GROUP BY atype;&lt;/code&gt;&lt;/p&gt;
&lt;table class=&#34;width-50pc center-inner-td f-left&#34;&gt;&lt;thead&gt;&lt;caption&gt;atype integer&lt;/caption&gt;
&lt;tr&gt;&lt;th&gt;кто&lt;/th&gt;&lt;th&gt;where&lt;/th&gt;&lt;th&gt;group&lt;/th&gt;&lt;/thead&gt;
&lt;tbody&gt;
    &lt;tr&gt;&lt;td&gt;SQLite&lt;/td&gt;&lt;td&gt;0.549&lt;/td&gt;&lt;td&gt;6.119&lt;/td&gt;&lt;/tr&gt;
    &lt;tr&gt;&lt;td&gt;Postgres&lt;/td&gt;&lt;td&gt;3.138&lt;/td&gt;&lt;td&gt;1.371&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;table class=&#34;width-50pc center-inner-td f-right&#34;&gt;&lt;thead&gt;&lt;caption&gt;atype string&lt;/caption&gt;
    &lt;tr&gt;&lt;th&gt;кто&lt;/th&gt;&lt;th&gt;where&lt;/th&gt;&lt;th&gt;group&lt;/th&gt;&lt;/thead&gt;
&lt;tbody&gt;
    &lt;tr&gt;&lt;td&gt;SQlite&lt;/td&gt;&lt;td&gt;0.779 (+41%)&lt;/td&gt;&lt;td&gt;9.532 (+55%)&lt;/td&gt;&lt;/tr&gt;
    &lt;tr&gt;&lt;td&gt;Postgres&lt;/td&gt;&lt;td&gt;14.698 (+368%) o_O&lt;/td&gt;&lt;td&gt;1.469 (+7%)&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;&lt;/p&gt;

&lt;div class=&#34;clearer&#34;&gt;&amp;nbsp;&lt;/div&gt;

&lt;p&gt;&lt;h2&gt;Выводы&lt;/h2&gt;
&lt;p&gt;Да, всё грубо, приближенно, можно натюнить на совсем другие числа, но.&lt;/p&gt;
&lt;p&gt;Если мы говорим о типах юзеров, статусах заказов, совершенно точно быстрее будет численное перечисление.&lt;/p&gt;
&lt;p&gt;Если речь идёт о какой-то таблице, в которой редко работают с одной записью, но чаще сразу со всей группой перечисления, то вам лучше не использовать SQLite :). А если записей немного (в пределах миллиона), то можно и строки, чёрт с вами.&lt;/p&gt;
&lt;p&gt;Я за числа везде и всегда. &lt;strong&gt;SQL, как и XML &amp;mdash; не для людей&lt;/strong&gt;. :)&lt;/p&gt;&lt;/p&gt;
</content>
</entry>
<entry>
  <id>a/python-mysql-windows-grabli.html</id>
  <author><name>Temoto</name></author>
  <title type="html">Python и MySQL / Windows - Первые грабли</title>
  <published>2008-04-24T00:00:00Z</published>
  <category term="программирование"></category>
  <link href="https://temoto.github.io/a/python-mysql-windows-grabli.html" rel="alternate"></link>
  <content type="html">
  &lt;p&gt;&lt;h1&gt;Грабли, на которые я наступил при работе с мусклом из питона под виндой&lt;/h1&gt;, хотя почти всё здесь жестко к винде не относится и применимо ко всем ОС.&lt;/p&gt;

&lt;p&gt;&lt;ol&gt;
&lt;li&gt;&lt;h3&gt;import MySQLdb&lt;/h3&gt;
&lt;p&gt;Не знаю почему, но у меня эта строчка не работала. mysql-python был установлен с помощью setuptools:&lt;/p&gt;
&lt;code&gt;easy_install mysql-python&lt;/code&gt;
&lt;p&gt;
Из site-packages/.egg я вытащил всё в site-packages.
Ну и убрал упоминание про egg из easy_install.pth, конечно.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Заработало!&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;small&gt;На #python сказали, что у меня, наверно, были проблемы с самим файликом .egg, или с PYTHON_PATH.&lt;/small&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;h3&gt;INSERT в никуда&lt;/h3&gt;
&lt;p&gt;Тут всё совсем просто. База InnoDB, по-умолчанию включены транзакции, модуль MySQLdb их по-умолчанию начинает. Нужно либо делать &lt;code&gt;connection.commit()&lt;/code&gt; после &lt;code&gt;cursor.execute()&lt;/code&gt;, либо, как мне больше понравилось, сделать &lt;code&gt;connection.autocommit(True)&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;h3&gt;INSERT в левой кодировке&lt;/h3&gt;
&lt;p&gt;Проблема кодировок и MySQL уже обсуждалась, тогда это был PHP, сегодня Python, всё иначе, прошло много времени, проблема кодировок живет. Извините, отступление.&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Удивительно, блядь, сколько еще понадобится времени, чтобы убрать нахер все кодировки и придти к единому соглашению. UTF-8 это позволяет. Не нравится — хакей, я тоже не против UTF-16. Файловые системы умеют сжимать файлики прозрачно. Даже в HTTP пришли к какому-то перемирию со сжатием (deflate vs. zlib или как там). Какие кроме размера могут быть недостатки, я вас спрашиваю? Скорость работы со строками? Да задействуйте уже наконец свои простаивающие сутками 4 ядра. 16 ядер и гигов памяти на десктопе это не фантастика, это завтра.&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;Ближе к делу. Я сторонник параметризованных запросов. Потому что я не желаю знать об оборачивании строк кавычками. Это не моя проблема.&lt;br&gt;
В питоновском DB-API существует несколько способов указывать параметризованные запросы. Самые распространённые: ? и %s.&lt;br&gt;
Модуль MySQLdb использует %s параметры. Подпихнуть ему %d на число у меня, почему-то не получилось. Но можно всё равно передавать числа, как будто это строка. Так вот, я пишу
&lt;code&gt;sql = &amp;ldquo;&amp;rdquo;&amp;ldquo;INSERT INTO &lt;code&gt;table&lt;/code&gt;&lt;br&gt;
(&lt;code&gt;name&lt;/code&gt;, &lt;code&gt;info&lt;/code&gt;, &lt;code&gt;length&lt;/code&gt;)&lt;br&gt;
VALUES (%s, %s, %s)&lt;br&gt;
;&amp;ldquo;&amp;rdquo;&amp;rdquo;&lt;br&gt;
sql_params = (u&amp;rsquo;меня зовут Вова&amp;rsquo;, u&amp;rsquo;Я знаю три слова&amp;rsquo;, 17)&lt;br&gt;
cursor.execute(sql, sql_params)&lt;br&gt;
&lt;/code&gt;
Обратите внимание, параметры - строки в Unicode. В рабочем скрипте они у меня получались из запроса, .decode(&amp;lsquo;utf-8&amp;rsquo;), но это неважно. MySQLdb должен сам уметь класть в базу строки в нужной кодировке. Мы работаем с Unicode.&lt;/p&gt;
&lt;p&gt;А он работает с latin1. Он не знает, что у нас в начале скрипта &lt;code&gt;# -&lt;em&gt;- coding: utf-8 -&lt;/em&gt;-&lt;/code&gt;, что у нас кодировка сервера, базы utf-8. Он знает про свой latin1. Нельзя винить, всё логично и последовательно.
&lt;/p&gt;
&lt;p&gt;Итак, чтобы заставить модуль кодировать строки во что нужно, я написал &lt;code&gt;connection.set_character_set(&amp;lsquo;utf8&amp;rsquo;)&lt;/code&gt;
Забавно выглядят два слова set. &lt;strong&gt;Обратите внимание. Не &amp;ldquo;utf-8&amp;rdquo;, а &amp;ldquo;utf8&amp;rdquo;.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Заработало!&lt;/strong&gt; Записи вставляются и вынимаются как надо.
&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;Успехов вам.&lt;/p&gt;&lt;/p&gt;
</content>
</entry>
</feed>
